{"version":3,"sources":["datapoint.js"],"names":["qtree","require","settings","axios","haversine","Datapoint","constructor","apiKey","ukArea","Rectangle","quadtree","ukBoundingArea","pointLimit","maxPointsPerNode","forecastSites","Quadtree","observationSites","ready","areaIncrementSize","init","cb","_queryForecastSites","catch","err","_queryObservationSites","get","datapoint","forecastPath","baseURL","params","key","timeout","then","response","data","Locations","Location","forEach","loc","point","Point","longitude","latitude","insertPoint","observationPath","_querySiteForecast","siteId","resolution","res","SiteRep","_querySiteObservations","_findNearest","location","locations","nearest","distance","newDistance","Set","add","getAllForecastSites","queryPoints","getAllObservationSites","getNearestObservationSite","size","queryArea","Area","results","getNearestForecastSite","getNearbyForecastSites","getForecast","getObservations","module","exports"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,mBAAD,CAArB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,WAAD,CAAzB;AACA;;;;;AAGA,MAAMI,SAAN,CAAgB;AACd;;;;;AAKAC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKC,MAAL,GAAc,IAAIR,KAAK,CAACS,SAAV,CAAoB,GAAGP,QAAQ,CAACQ,QAAT,CAAkBC,cAAzC,CAAd;AACA,SAAKC,UAAL,GAAkBV,QAAQ,CAACQ,QAAT,CAAkBG,gBAApC;AACA,SAAKC,aAAL,GAAqB,IAAId,KAAK,CAACe,QAAV,CAAmB,KAAKP,MAAxB,EAAgC,KAAKI,UAArC,CAArB;AACA,SAAKI,gBAAL,GAAwB,IAAIhB,KAAK,CAACe,QAAV,CAAmB,KAAKP,MAAxB,EAAgC,KAAKI,UAArC,CAAxB;AACA,SAAKK,KAAL,GAAa,KAAb;AACA,SAAKC,iBAAL,GAAyBhB,QAAQ,CAACQ,QAAT,CAAkBQ,iBAA3C;AACD;AACD;;;;;;;AAKA,QAAMC,IAAN,CAAWC,EAAX,EAAe;AACb,QAAI,CAAC,KAAKH,KAAV,EAAiB;AACf,YAAM,KAAKI,mBAAL,GAA2BC,KAA3B,CAAkCC,GAAD,IAAS;AAC9C,aAAKN,KAAL,GAAa,KAAb,CAD8C,CAE9C;AACD,OAHK,CAAN;AAIA,YAAM,KAAKO,sBAAL,GAA8BF,KAA9B,CAAqCC,GAAD,IAAS;AACjD,aAAKN,KAAL,GAAa,KAAb,CADiD,CAEjD;AACD,OAHK,CAAN;AAID;;AACD,SAAKA,KAAL,GAAa,IAAb,CAXa,CAYb;;AACAG,IAAAA,EAAE,CAAC,KAAKH,KAAN,CAAF;AACD;AACD;;;;;;;AAKAI,EAAAA,mBAAmB,GAAG;AACpB,WAAOlB,KAAK,CAACsB,GAAN,CACHvB,QAAQ,CAACwB,SAAT,CAAmBC,YAAnB,GAAkC,UAD/B,EAEH;AAACC,MAAAA,OAAO,EAAE1B,QAAQ,CAACwB,SAAT,CAAmBE,OAA7B;AACEC,MAAAA,MAAM,EAAE;AAACC,QAAAA,GAAG,EAAE,KAAKvB;AAAX,OADV;AAEEwB,MAAAA,OAAO,EAAE7B,QAAQ,CAACwB,SAAT,CAAmBK;AAF9B,KAFG,EAKLC,IALK,CAKCC,QAAD,IAAc;AACnBA,MAAAA,QAAQ,CAACC,IAAT,CAAcC,SAAd,CAAwBC,QAAxB,CAAiCC,OAAjC,CAA0CC,GAAD,IAAS;AAChD,cAAMC,KAAK,GAAG,IAAIvC,KAAK,CAACwC,KAAV,CAAgBF,GAAG,CAACG,SAApB,EAA+BH,GAAG,CAACI,QAAnC,EAA6CJ,GAA7C,CAAd;AACA,aAAKxB,aAAL,CAAmB6B,WAAnB,CAA+BJ,KAA/B;AACD,OAHD;AAID,KAVM,CAAP;AAWD;AACD;;;;;;;AAKAf,EAAAA,sBAAsB,GAAG;AACvB,WAAOrB,KAAK,CAACsB,GAAN,CACHvB,QAAQ,CAACwB,SAAT,CAAmBkB,eAAnB,GAAqC,UADlC,EAEH;AAAChB,MAAAA,OAAO,EAAE1B,QAAQ,CAACwB,SAAT,CAAmBE,OAA7B;AACEC,MAAAA,MAAM,EAAE;AAACC,QAAAA,GAAG,EAAE,KAAKvB;AAAX,OADV;AAEEwB,MAAAA,OAAO,EAAE7B,QAAQ,CAACwB,SAAT,CAAmBK;AAF9B,KAFG,EAKLC,IALK,CAKCC,QAAD,IAAc;AACnBA,MAAAA,QAAQ,CAACC,IAAT,CAAcC,SAAd,CAAwBC,QAAxB,CAAiCC,OAAjC,CAA0CC,GAAD,IAAS;AAChD,cAAMC,KAAK,GAAG,IAAIvC,KAAK,CAACwC,KAAV,CAAgBF,GAAG,CAACG,SAApB,EAA+BH,GAAG,CAACI,QAAnC,EAA6CJ,GAA7C,CAAd;AACA,aAAKtB,gBAAL,CAAsB2B,WAAtB,CAAkCJ,KAAlC;AACD,OAHD;AAID,KAVM,CAAP;AAWD;AACD;;;;;;;;;AAOAM,EAAAA,kBAAkB,CAACC,MAAD,EAASC,UAAT,EAAqB;AACrC,WAAO5C,KAAK,CAACsB,GAAN,CACHvB,QAAQ,CAACwB,SAAT,CAAmBC,YAAnB,GAAkCmB,MAD/B,EAEH;AAAClB,MAAAA,OAAO,EAAE1B,QAAQ,CAACwB,SAAT,CAAmBE,OAA7B;AACEC,MAAAA,MAAM,EAAE;AAACmB,QAAAA,GAAG,EAAED,UAAN;AAAkBjB,QAAAA,GAAG,EAAE,KAAKvB;AAA5B,OADV;AAEEwB,MAAAA,OAAO,EAAE7B,QAAQ,CAACwB,SAAT,CAAmBK;AAF9B,KAFG,EAKLC,IALK,CAKCC,QAAD,IAAc;AACnB,aAAOA,QAAQ,CAACC,IAAT,CAAce,OAArB;AACD,KAPM,EAOJ3B,KAPI,CAOGC,GAAD,IAASA,GAPX,CAAP;AAQD;AACD;;;;;;;;AAMA2B,EAAAA,sBAAsB,CAACJ,MAAD,EAASC,UAAU,GAAG,QAAtB,EAAgC;AACpD,WAAO5C,KAAK,CAACsB,GAAN,CACHvB,QAAQ,CAACwB,SAAT,CAAmBkB,eAAnB,GAAqCE,MADlC,EAEH;AAAClB,MAAAA,OAAO,EAAE1B,QAAQ,CAACwB,SAAT,CAAmBE,OAA7B;AACEC,MAAAA,MAAM,EAAE;AAACmB,QAAAA,GAAG,EAAED,UAAN;AAAkBjB,QAAAA,GAAG,EAAE,KAAKvB;AAA5B,OADV;AAEEwB,MAAAA,OAAO,EAAE7B,QAAQ,CAACwB,SAAT,CAAmBK;AAF9B,KAFG,EAKLC,IALK,CAKCC,QAAD,IAAc;AACnB,aAAOA,QAAQ,CAACC,IAAT,CAAce,OAArB;AACD,KAPM,EAOJ3B,KAPI,CAOGC,GAAD,IAASA,GAPX,CAAP;AAQD;AACD;;;;;;;;AAMA4B,EAAAA,YAAY,CAACC,QAAD,EAAWC,SAAX,EAAsB;AAChC,QAAIC,OAAJ;AACA,QAAIC,QAAJ;AACAF,IAAAA,SAAS,CAAChB,OAAV,CAAmBC,GAAD,IAAS;AACzB,YAAMkB,WAAW,GAAGpD,SAAS,CAACgD,QAAD,EACzB;AAACV,QAAAA,QAAQ,EAAEJ,GAAG,CAACJ,IAAJ,CAASQ,QAApB;AAA8BD,QAAAA,SAAS,EAAEH,GAAG,CAACJ,IAAJ,CAASO;AAAlD,OADyB,CAA7B;;AAEA,UAAIe,WAAW,GAAGD,QAAd,IAA0B,OAAOA,QAAP,KAAoB,WAAlD,EAA+D;AAC7DA,QAAAA,QAAQ,GAAGC,WAAX;AACAF,QAAAA,OAAO,GAAGhB,GAAV;AACD;AACF,KAPD;AASA,WAAO,IAAImB,GAAJ,GAAUC,GAAV,CAAcJ,OAAd,CAAP;AACD;AACD;;;;;;;AAKAK,EAAAA,mBAAmB,GAAG;AACpB,QAAI,KAAK1C,KAAT,EAAgB;AACd,aAAO,KAAKH,aAAL,CAAmB8C,WAAnB,EAAP;AACD;AACF;AACD;;;;;;;AAKAC,EAAAA,sBAAsB,GAAG;AACvB,QAAI,KAAK5C,KAAT,EAAgB;AACd,aAAO,KAAKD,gBAAL,CAAsB4C,WAAtB,EAAP;AACD;AACF;AACD;;;;;;;;AAMAE,EAAAA,yBAAyB,CAACxB,GAAD,EAAMyB,IAAI,GAAG,CAAb,EAAgB;AACvC,UAAMC,SAAS,GAAG,IAAIhE,KAAK,CAACiE,IAAV,CAAe3B,GAAG,CAACG,SAAnB,EAA8BH,GAAG,CAACI,QAAlC,EAA4CqB,IAA5C,EAAkDA,IAAlD,CAAlB;AACA,UAAMG,OAAO,GAAG,KAAKlD,gBAAL,CAAsB4C,WAAtB,CAAkCI,SAAlC,CAAhB,CAFuC,CAGvC;;AACA,QAAIE,OAAO,CAACH,IAAR,KAAiB,CAArB,EAAwB;AACtB,aAAOG,OAAP;AACD,KANsC,CAOvC;;;AACA,QAAIA,OAAO,CAACH,IAAR,GAAe,CAAnB,EAAsB;AACpB,aAAO,KAAKZ,YAAL,CAAkBb,GAAlB,EAAuB4B,OAAvB,CAAP;AACD,KAVsC,CAWvC;;;AACA,QAAIA,OAAO,CAACH,IAAR,KAAiB,CAArB,EAAwB;AACtBA,MAAAA,IAAI,IAAI,KAAK7C,iBAAb;AACA,aAAO,KAAK4C,yBAAL,CAA+BxB,GAA/B,EAAoCyB,IAApC,CAAP;AACD;AACF;AACD;;;;;;;;AAMAI,EAAAA,sBAAsB,CAAC7B,GAAD,EAAMyB,IAAI,GAAG,CAAb,EAAgB;AACpC,UAAMC,SAAS,GAAG,IAAIhE,KAAK,CAACiE,IAAV,CAAe3B,GAAG,CAACG,SAAnB,EAA8BH,GAAG,CAACI,QAAlC,EAA4CqB,IAA5C,EAAkDA,IAAlD,CAAlB;AACA,UAAMG,OAAO,GAAG,KAAKpD,aAAL,CAAmB8C,WAAnB,CAA+BI,SAA/B,CAAhB,CAFoC,CAGpC;;AACA,QAAIE,OAAO,CAACH,IAAR,KAAiB,CAArB,EAAwB;AACtB,aAAOG,OAAP;AACD,KANmC,CAOpC;;;AACA,QAAIA,OAAO,CAACH,IAAR,GAAe,CAAnB,EAAsB;AACpB,aAAO,KAAKZ,YAAL,CAAkBb,GAAlB,EAAuB4B,OAAvB,CAAP;AACD,KAVmC,CAWpC;;;AACA,QAAIA,OAAO,CAACH,IAAR,KAAiB,CAArB,EAAwB;AACtBA,MAAAA,IAAI,IAAI,KAAK7C,iBAAb;AACA,aAAO,KAAKiD,sBAAL,CAA4B7B,GAA5B,EAAiCyB,IAAjC,CAAP;AACD;AACF;AACD;;;;;;;;;AAOAK,EAAAA,sBAAsB,CAAC9B,GAAD,EAAMyB,IAAN,EAAY;AAChC,UAAMC,SAAS,GAAG,IAAIhE,KAAK,CAACiE,IAAV,CAAe3B,GAAG,CAACG,SAAnB,EAA8BH,GAAG,CAACI,QAAlC,EAA4CqB,IAA5C,EAAkDA,IAAlD,CAAlB;AACA,WAAO,KAAKjD,aAAL,CAAmB8C,WAAnB,CAA+BI,SAA/B,CAAP;AACD;AAED;;;;;;;;;AAOA,QAAMK,WAAN,CAAkBvB,MAAlB,EAA0BC,UAA1B,EAAsC;AACpC,QAAI,KAAK9B,KAAT,EAAgB;AACd,aAAO,MAAM,KAAK4B,kBAAL,CAAwBC,MAAxB,EAAgCC,UAAhC,CAAb;AACD;AACF;AACD;;;;;;AAIA,QAAMuB,eAAN,CAAsBxB,MAAtB,EAA8B;AAC5B,WAAO,MAAM,KAAKI,sBAAL,CAA4BJ,MAA5B,CAAb;AACD;;AA5Na;;AA8NhByB,MAAM,CAACC,OAAP,GAAiBnE,SAAjB","sourcesContent":["const qtree = require('@slatham/quadtree');\nconst settings = require('./settings');\nconst axios = require('axios');\nconst haversine = require('haversine');\n/**\n * Describe datapoint class\n */\nclass Datapoint {\n  /**\n   * Set up the datapoint object\n   * set the API key\n   * @param {String} apiKey\n   */\n  constructor(apiKey) {\n    this.apiKey = apiKey;\n    this.ukArea = new qtree.Rectangle(...settings.quadtree.ukBoundingArea);\n    this.pointLimit = settings.quadtree.maxPointsPerNode;\n    this.forecastSites = new qtree.Quadtree(this.ukArea, this.pointLimit);\n    this.observationSites = new qtree.Quadtree(this.ukArea, this.pointLimit);\n    this.ready = false;\n    this.areaIncrementSize = settings.quadtree.areaIncrementSize;\n  }\n  /**\n   * Set up the class ready\n   * for use by pre-loading site lists\n   * @param {function} cb\n   */\n  async init(cb) {\n    if (!this.ready) {\n      await this._queryForecastSites().catch((err) => {\n        this.ready = false;\n        // console.log(err);\n      });\n      await this._queryObservationSites().catch((err) => {\n        this.ready = false;\n        // console.log(err);\n      });\n    }\n    this.ready = true;\n    // console.log('ready...');\n    cb(this.ready);\n  }\n  /**\n   * Pull all the forecast sites\n   * from the datapoint API\n   * @return {Promise}\n   */\n  _queryForecastSites() {\n    return axios.get(\n        settings.datapoint.forecastPath + 'sitelist',\n        {baseURL: settings.datapoint.baseURL,\n          params: {key: this.apiKey},\n          timeout: settings.datapoint.timeout}\n    ).then((response) => {\n      response.data.Locations.Location.forEach((loc) => {\n        const point = new qtree.Point(loc.longitude, loc.latitude, loc);\n        this.forecastSites.insertPoint(point);\n      });\n    });\n  }\n  /**\n   * Pull all the observation sites\n   * from the datapoint API\n   * @return {Promise}\n   */\n  _queryObservationSites() {\n    return axios.get(\n        settings.datapoint.observationPath + 'sitelist',\n        {baseURL: settings.datapoint.baseURL,\n          params: {key: this.apiKey},\n          timeout: settings.datapoint.timeout}\n    ).then((response) => {\n      response.data.Locations.Location.forEach((loc) => {\n        const point = new qtree.Point(loc.longitude, loc.latitude, loc);\n        this.observationSites.insertPoint(point);\n      });\n    });\n  }\n  /**\n   * Query the datapoint API for\n   * forecast data for a given site\n   * @param {int} siteId\n   * @param {String} resolution\n   * @return {Object}\n   */\n  _querySiteForecast(siteId, resolution) {\n    return axios.get(\n        settings.datapoint.forecastPath + siteId,\n        {baseURL: settings.datapoint.baseURL,\n          params: {res: resolution, key: this.apiKey},\n          timeout: settings.datapoint.timeout}\n    ).then((response) => {\n      return response.data.SiteRep;\n    }).catch((err) => err);\n  }\n  /**\n   * Get hourly observations for a site\n   * @param {Int} siteId\n   * @param {String} resolution\n   * @return {Promise}\n   */\n  _querySiteObservations(siteId, resolution = 'hourly') {\n    return axios.get(\n        settings.datapoint.observationPath + siteId,\n        {baseURL: settings.datapoint.baseURL,\n          params: {res: resolution, key: this.apiKey},\n          timeout: settings.datapoint.timeout}\n    ).then((response) => {\n      return response.data.SiteRep;\n    }).catch((err) => err);\n  }\n  /**\n   * use haversine to find nearest site\n   * @param {Object} location\n   * @param {Set} locations\n   * @return {Set}\n   */\n  _findNearest(location, locations) {\n    let nearest;\n    let distance;\n    locations.forEach((loc) => {\n      const newDistance = haversine(location,\n          {latitude: loc.data.latitude, longitude: loc.data.longitude});\n      if (newDistance < distance || typeof distance === 'undefined') {\n        distance = newDistance;\n        nearest = loc;\n      }\n    });\n\n    return new Set().add(nearest);\n  }\n  /**\n   * Get a list of all the sites where forecast\n   * data is available\n   * @return {Set}\n   */\n  getAllForecastSites() {\n    if (this.ready) {\n      return this.forecastSites.queryPoints();\n    }\n  }\n  /**\n   * Get a list of all the sites where observation\n   * data is available\n   * @return {Set}\n   */\n  getAllObservationSites() {\n    if (this.ready) {\n      return this.observationSites.queryPoints();\n    }\n  }\n  /**\n   * Get nearest site to a given location\n   * @param {object} loc\n   * @param {int} size\n   * @return {Set}\n   */\n  getNearestObservationSite(loc, size = 0) {\n    const queryArea = new qtree.Area(loc.longitude, loc.latitude, size, size);\n    const results = this.observationSites.queryPoints(queryArea);\n    // early return bit base case\n    if (results.size === 1) {\n      return results;\n    }\n    // return nearest\n    if (results.size > 0) {\n      return this._findNearest(loc, results);\n    }\n    // recursive bit\n    if (results.size === 0) {\n      size += this.areaIncrementSize;\n      return this.getNearestObservationSite(loc, size);\n    }\n  }\n  /**\n   * Get the nearest site to a give location\n   * @param {Object} loc\n   * @param {Float} size\n   * @return {Set}\n   */\n  getNearestForecastSite(loc, size = 0) {\n    const queryArea = new qtree.Area(loc.longitude, loc.latitude, size, size);\n    const results = this.forecastSites.queryPoints(queryArea);\n    // early return bit base case\n    if (results.size === 1) {\n      return results;\n    }\n    // return nearest\n    if (results.size > 0) {\n      return this._findNearest(loc, results);\n    }\n    // recursive bit\n    if (results.size === 0) {\n      size += this.areaIncrementSize;\n      return this.getNearestForecastSite(loc, size);\n    }\n  }\n  /**\n   * Get the nearest sites based on a location\n   * @param {Object} loc\n   * @param {Float} size\n   * Should return an object containing a Set() of points\n   * @return {Set}\n   */\n  getNearbyForecastSites(loc, size) {\n    const queryArea = new qtree.Area(loc.longitude, loc.latitude, size, size);\n    return this.forecastSites.queryPoints(queryArea);\n  }\n\n  /**\n   * Get a forecast for\n   * a given site\n   * @param {Int} siteId\n   * @param {String} resolution\n   * @return {Promise}\n   */\n  async getForecast(siteId, resolution) {\n    if (this.ready) {\n      return await this._querySiteForecast(siteId, resolution);\n    }\n  }\n  /**\n   * Get 24h hourly observations\n   * @param {Int} siteId\n   */\n  async getObservations(siteId) {\n    return await this._querySiteObservations(siteId);\n  }\n}\nmodule.exports = Datapoint;\n"],"file":"datapoint.js"}